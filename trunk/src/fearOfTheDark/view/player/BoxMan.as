package fearOfTheDark.view.player{		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import shapes.*;	import misc.*;	import extras.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;		import fearOfTheDark.view.enemies.Enemy;		public class BoxMan extends Box {				public var contacts:ContactList;		var isTeleportingR:Boolean = false;		var isTeleportingL:Boolean = false;				var left:Boolean;		var right:Boolean;		var jump:Boolean;		var atack:Boolean;				public override function create():void {			reportBeginContact = true;			reportEndContact = true;			fixedRotation = true;			super.create();			listenWhileVisible(world, StepEvent.STEP, parseInput, false, 10);			listenWhileVisible(this, ContactEvent.BEGIN_CONTACT, handleContact);						stage.addEventListener(KeyboardEvent.KEY_UP, keyUpHandler);						setTimeout(teleportBoy, 50);						contacts = new ContactList();			contacts.listenTo(this);								}				private function keyUpHandler(evt:KeyboardEvent):void 		{			//trace ("UPUPUP")			//trace (this.currentLabel);			if (this.currentLabel == "walkR")			{				gotoAndStop("idleR");			}			else if (this.currentLabel == "walkL")			{				gotoAndStop("idleL");			}			//else (this.currentLabel == "atackR" || this.currentLabel == "atackL")			else 			{				//gotoAndStop("idleL");			}		}				private function achaTodosNoPadrao(padrao:RegExp, local:Object, type:int)		{			for (var i=local.numChildren-1; i>=0; i--)			{				if (padrao.test(local.getChildAt(i).name))				{					switch (type)					{						case 1:							local.removeChildAt(i);							break;													// Stun!						case 2:							Enemy(local.getChildAt(i)).receiveDamage();							break;													// Boy killed - freeze						case 3:							Enemy(local.getChildAt(i)).freezeEnemy();							break;					}				}			}		}				public function handleContact(e:ContactEvent):void {			//trace("e.relatedObject.name = " + e.relatedObject.name);			//trace("e.target.name = " + e.target.name);						if (e.relatedObject is Enemy)			{				Enemy(e.relatedObject).hitBoy();				die();				achaTodosNoPadrao(new RegExp(/enemy/), parent, 3);			}						var p:Pellet = e.other.m_userData as Pellet;			if(p) {				Util.addChildAtPosOf(world, new FX(), p);  				p.remove();			}						trace (e.relatedObject.name);			if (e.relatedObject.name == "warpR")			{				//this.x = -200;				//this.syncTransform();						isTeleportingR = true;			}			else if (e.relatedObject.name == "warpL")			{				//this.x = -200;				//this.syncTransform();						isTeleportingL = true;			}		}				function teleportBoy ():void		{						if (isTeleportingR)			{								isTeleportingR = false;				this.x = -1700;				this.syncTransform();				}			else if (isTeleportingL)			{								isTeleportingL = false;				this.x = 1500;				this.syncTransform();				}						setTimeout(teleportBoy, 50);					}						public function parseInput(e:Event):void {			var manifold:b2WorldManifold = null;			var dot:Number = -1;						// Search for the most ground/floor-like contact.			if(!contacts.isEmpty()) {				contacts.forEach(function(keys:Array, c:ContactEvent) {					var wm:b2WorldManifold = c.getWorldManifold();					if(wm.normal) { 												// Dot producting the contact normal with gravity indicates how floor-like the						// contact is. If the dot product = 1, it is a flat foor. If it is -1, it is						// a ceiling. If it's 0.5, it's a sloped floor. Save the contact manifold						// that is the most floor like.						var d:Number = wm.normal.dot(gravity);						if(!manifold || d > dot) {							manifold = wm;							dot = d;						}					}				});				contacts.clean();			}						if (this.currentLabel != "dieR" && this.currentLabel != "dieL")			{								left = Input.kd('A', 'LEFT');				right = Input.kd('D', 'RIGHT');				jump = Input.kp('W', 'UP');				atack = Input.kp(' ', 'P');			}						var v:V2;						// Here we could add a dot product threshold for disallowing the player from jumping			// off of walls, ceilings, etc. For example:			// if(jump && manifold && dot > 0) {			if(jump && manifold) {				v = manifold.normal.clone().multiplyN(-20);				b2body.ApplyImpulse(v, b2body.GetWorldCenter());			}			else if(left) {				b2body.SetAwake(true);				b2body.SetLinearVelocity(new V2( -2, b2body.GetLinearVelocity().y)) 				setTimeout(soltar, 50);									gotoAndStop("walkL");												//trace (Object(parent).light.x);								Object(parent).light.x = this.x;				Object(parent).lightFoot.x = this.x;																//Object(parent).darkness.x = this.x;				//Object(parent).darkness.y = this.y;							}			else if(right) {				b2body.SetAwake(true);				b2body.SetLinearVelocity(new V2(2, b2body.GetLinearVelocity().y)) 				setTimeout(soltar, 50);										gotoAndStop("walkR");								Object(parent).light.x = this.x;				Object(parent).lightFoot.x = this.x;								//Object(parent).darkness.x = this.x;				//Object(parent).darkness.y = this.y;								/*				for (var i=0; i<parent.numChildren; i++)				{					trace(i+" - ", parent.getChildAt(i).name);				}				*/			}			else if (atack) 			{				//trace (this.currentLabel)				if (this.currentLabel == "idleR")				{					gotoAndStop("atackR");				}				else				{					gotoAndStop("atackL");				}				Object(parent.parent).darkness.play();				achaTodosNoPadrao(new RegExp(/enemy/), parent, 2);			}		}				private function soltar(){			b2body.SetLinearVelocity(new V2(0, b2body.GetLinearVelocity().y))		}				// Damage		public function die():void		{			//trace ("DIE", this.currentLabel);						left = false;			right = false;						if (this.currentLabel == "idleR" || this.currentLabel == "atackR" || this.currentLabel == "walkR")			{				gotoAndStop("dieR");			}			else if (this.currentLabel == "idleL" || this.currentLabel == "atackL" || this.currentLabel == "walkL")			{				gotoAndStop("dieL");			}		}	}}